{"version":3,"file":"index.browser.min.js","sources":["../src/AuthorsMap.ts","../src/PluginCache.ts","../src/VariablesMap.ts","../src/index.ts"],"sourcesContent":["/**\n * Interface that defines the type for the fields that are specified for authors\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface AuthorFields\n * @typedef {AuthorFields}\n */\nexport interface AuthorFields {\n  /** The type of the author. */\n  type?: string;\n  /** The name of the author. (required) */\n  name: string;\n  /** The given name of the author. */\n  givenName?: string;\n  /** The family name of the author. */\n  familyName?: string;\n  /** The identifier that distinguishes the author across datasets (URL). */\n  identifier?: string;\n}\n\n/**\n * Class that helps keep track of authors and allows for easy conversion to list format when\n * generating the final Metadata file.\n *\n * @export\n * @class AuthorsMap\n * @typedef {AuthorsMap}\n */\nexport class AuthorsMap {\n  /**\n   * Field that keeps track of the authors in a map.\n   *\n   * @private\n   * @type {({ [key: string]: AuthorFields | string })}\n   */\n  private authors: { [key: string]: AuthorFields | string };\n\n  /**\n   * Creates an empty instance of authors map. Doesn't generate default metadata because\n   * can't assume anything about the authors.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.authors = {};\n  }\n\n  /**\n   * Returns the final list format of the authors according to Psych-DS standards.\n   *\n   * @returns {(AuthorFields | string)[]} - List of authors\n   */\n  getList(): (AuthorFields | string)[] {\n    const author_list = [];\n    for (const key of Object.keys(this.authors)) {\n      author_list.push(this.authors[key]);\n    }\n    return author_list;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(author: AuthorFields | string): void {\n    // Handling string input\n    if (typeof author === \"string\") {\n      this.authors[author] = author;\n      return;\n    }\n\n    if (!author.name) {\n      console.warn(\"Name field is missing. Author not added.\");\n      return;\n    }\n\n    const { name, ...rest } = author;\n\n    if (Object.keys(rest).length == 0) {\n      this.authors[name] = name;\n    } else {\n      const newAuthor: AuthorFields = { name, ...rest };\n      this.authors[name] = newAuthor;\n\n      const unexpectedFields = Object.keys(author).filter(\n        (key) => ![\"type\", \"name\", \"givenName\", \"familyName\", \"identifier\"].includes(key)\n      );\n      if (unexpectedFields.length > 0) {\n        console.warn(\n          `Unexpected fields (${unexpectedFields.join(\n            \", \"\n          )}) detected and included in the author object.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    if (name in this.authors) {\n      return this.authors[name];\n    } else {\n      console.warn(\"Author (\", name, \") not found.\");\n      return {};\n    }\n  }\n}\n","export class PluginCache {\n  private pluginFields: { [key: string]: {} };\n\n  constructor() {\n    this.pluginFields = {}; // caching previous results\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  async getPluginInfo(pluginType: string, variableName: string) {\n    if (pluginType in this.pluginFields) {\n      return this.pluginFields[pluginType][variableName];\n    } else {\n      console.log(\"doesn't exist -- plugintype:\", pluginType, \"variableName:\", variableName); // checking search\n\n      const fields = await this.generatePluginFields(pluginType);\n      this.pluginFields[pluginType] = fields;\n      console.log(fields);\n      return fields[variableName];\n    }\n  }\n\n  private async generatePluginFields(pluginType: string) {\n    const script = await this.fetchScript(pluginType);\n    const fields = this.parseJavadocString(script);\n    return fields;\n  }\n\n  private async fetchScript(pluginType: string) {\n    // const unpkgUrl = `https://unpkg.com/@jspsych/plugin-${pluginType}/src/index.ts`;\n    const unpkgUrl = `http://localhost:3000/plugin/${pluginType}/index.ts`;\n\n    try {\n      const response = await fetch(unpkgUrl);\n      const scriptContent = await response.text();\n      return scriptContent;\n    } catch (error) {\n      console.error(`Unexpected error occurred:`, error);\n      return undefined;\n    }\n  }\n\n  // written with the help of chatgpt\n  private parseJavadocString(script: string) {\n    const dataString = script.match(/data:\\s*{([\\s\\S]*?)};\\s*/).join();\n    const result = {};\n    // Regular expression to match each variable block\n    const varRegex = /\\/\\*\\*\\s*([\\s\\S]*?)\\s*\\*\\/\\s*(\\w+):\\s*{\\s*([\\s\\S]*?)\\s*},?/gs;\n    const propRegex = /\\s*(\\w+):\\s*([^,\\s]+)/g;\n\n    // Match each variable block\n    let match;\n    while ((match = varRegex.exec(dataString)) !== null) {\n      let [, description, varName, props] = match;\n      description = description.trim().replace(/\\s+/g, \" \"); // Clean up description\n\n      const propsObj = {};\n      let propMatch;\n      while ((propMatch = propRegex.exec(props)) !== null) {\n        let [, propName, propValue] = propMatch;\n        propsObj[propName] = propValue;\n      }\n\n      result[varName] = {\n        description: description,\n        ...propsObj, // Add all additional properties to the result object\n      };\n    }\n\n    return result;\n  }\n}\n","/**\n * Interface that defines the type for the fields that are specified for variables\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface VariableFields\n * @typedef {VariableFields}\n */\nexport interface VariableFields {\n  type?: string;\n  name: string; // required\n  description?: string | Record<string, string>;\n  value?: string; // string, boolean, or number\n  identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  minValue?: number;\n  maxValue?: number;\n  levels?: string[] | []; // technically property values in the other one but not sure how to format it\n  levelsOrdered?: boolean;\n  na?: boolean;\n  naValue?: string;\n  alternateName?: string;\n  privacy?: string;\n}\n\n/**\n * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n *\n * @export\n * @class VariablesMap\n * @typedef {VariablesMap}\n */\nexport class VariablesMap {\n  /**\n   * Field that holds a map of the current variables allowing for fast look-up.\n   *\n   * @private\n   * @type {{ [key: string]: VariableFields }}\n   */\n  private variables: { [key: string]: VariableFields };\n\n  /**\n   *  Creates the VariablesMap bycalling generateDefaultVariables() method to\n   * generate the basic metadata common to every dataset_description.json file.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.generateDefaultVariables();\n  }\n\n  /**\n   * Generates the default variables shared between every JsPsych experiment and fills in\n   * with default descriptions according to JsPsych documentation.\n   */\n  generateDefaultVariables(): void {\n    this.variables = {};\n\n    const trial_type_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_type\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The name of the plugin used to run the trial.\",\n      },\n      value: \"string\",\n    };\n    this.setVariable(trial_type_var);\n\n    const trial_index_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_index\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The index of the current trial across the whole experiment.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(trial_index_var);\n\n    const time_elapsed_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"time_elapsed\",\n      description: {\n        default: \"unknown\",\n        jsPsych:\n          \"The number of milliseconds between the start of the experiment and when the trial ended.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(time_elapsed_var);\n  }\n\n  /**\n   * Returns a list of the variables instead of an object according to the Psych-DS format.\n   *\n   * @returns {{}[]} - The list of variables represented as objects.\n   */\n  getList(): {}[] {\n    var var_list = [];\n\n    // need to check that this works as intended\n    for (const key of Object.keys(this.variables)) {\n      const variable = this.variables[key];\n      const description = variable[\"description\"];\n      const numKeys = Object.keys(description).length;\n\n      if (numKeys === 0) console.error(\"Empty description\"); // error: description empty\n      else if (numKeys === 1) {\n        // description becomes single field (assumed to be default)\n        const key = Object.keys(description)[0];\n        variable[\"description\"] = description[key];\n      } else if (numKeys == 2) {\n        delete description[\"default\"]; // deletes default\n\n        if (Object.keys(description).length == 1) {\n          // error checking that it reduced to one key\n          const key = Object.keys(description)[0];\n          variable[\"description\"] = description[key];\n        }\n      } else if (numKeys > 2) {\n        // deletes default\n        delete description[\"default\"];\n      }\n\n      var_list.push(variable);\n    }\n    return var_list;\n  }\n\n  /**\n   * Allows user to set a variable and includes all the fields that are possible according to\n   * Psych-DS guidelines. Only requires the name field which it uses a key to map to the variable.\n   * Can also be used to overwrite existing variables if they have the same name.\n   *\n   * @param {VariableFields} variable - The fields of the variable that is being created.\n   */\n  setVariable(variable: VariableFields): void {\n    if (!variable.name) {\n      // Ensure name is provided\n      console.warn(\"Name field is missing. Variable not added.\", variable);\n      return;\n    }\n\n    this.variables[variable.name] = variable;\n\n    const unexpectedFields = Object.keys(variable).filter(\n      (key) =>\n        ![\n          \"type\",\n          \"name\",\n          \"description\",\n          \"value\",\n          \"identifier\",\n          \"minValue\",\n          \"maxValue\",\n          \"levels\",\n          \"levelsOrdered\",\n          \"na\",\n          \"naValue\",\n          \"alternateName\",\n          \"privacy\",\n        ].includes(key)\n    );\n    if (unexpectedFields.length > 0) {\n      console.warn(\n        `Unexpected fields (${unexpectedFields.join(\n          \", \"\n        )}) detected and included in the variable object.`\n      );\n    }\n  }\n\n  /**\n   * Allows you to get information for a single variable returning empty dict if it doesn't exist.\n   * Allows you to update fields but not recommended in favor of updateVariable.\n   *\n   * @param {string} name\n   * @returns {(VariableFields | {})} - Variable information or empty dict if doesn't exist\n   */\n  getVariable(name: string): VariableFields | {} {\n    return this.variables[name] || {};\n  }\n\n  /**\n   * Checks if variable exists in VariablesMap.\n   *\n   * @param {string} name - Name of variable\n   * @returns {boolean} - True if exists, false if doesn't.\n   */\n  containsVariable(name: string): boolean {\n    return name in this.variables;\n  }\n\n  /**\n   * Method that gets a list of the names of variables.\n   *\n   * @returns {string[]} - String list containing names of existing variables.\n   */\n  getVariableNames(): string[] {\n    var var_list = [];\n    for (const key of Object.keys(this.variables)) {\n      var_list.push(this.variables[key][\"name\"]);\n    }\n\n    return var_list;\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value. Has special cases and logic for levels and names making it\n   * easier to update variable values.\n   *\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Specific field to be updated.\n   * @param {(string | boolean | number | { [key: string]: string })} added_value - Single value to be updated, with a mapping if adding to description with key representing pluginType.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | { [key: string]: string }\n  ): void {\n    const updated_var = this.getVariable(var_name);\n\n    if (Object.keys(updated_var).length === 0) {\n      // error checking to see variable exists\n      console.error(`Variable \"${var_name}\" does not exist.`);\n      return;\n    }\n\n    if (field_name === \"levels\") {\n      this.updateLevels(updated_var, added_value);\n    } else if (field_name === \"minValue\" || field_name === \"maxValue\") {\n      this.updateMinMax(updated_var, added_value, field_name);\n    } else if (field_name === \"description\") {\n      this.updateDescription(updated_var, added_value);\n    } else if (field_name === \"name\") {\n      this.updateName(updated_var, added_value);\n    } else {\n      updated_var[field_name] = added_value;\n    }\n  }\n\n  /**\n   * Logic that handles updates to levels field by creating new array if necessary, otherwise\n   * pushing the value if it doesn't already exist. Levels can only be added to with strings.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value being added to the levels field.\n   */\n  private updateLevels(updated_var, added_value): void {\n    if (!Array.isArray(updated_var[\"levels\"])) {\n      updated_var[\"levels\"] = [];\n    }\n    if (!updated_var[\"levels\"].includes(added_value)) {\n      updated_var[\"levels\"].push(added_value);\n    }\n  }\n\n  /**\n   * Logic to update the min and max for the specific value.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value that is being checked against current min/max.\n   * @param {*} field_name - The name of field that is being checked (min or max).\n   */\n  private updateMinMax(updated_var, added_value, field_name): void {\n    // check if min or max\n    if (!(\"minValue\" in updated_var) || !(\"maxValue\" in updated_var)) {\n      updated_var[\"maxValue\"] = updated_var[\"minValue\"] = added_value;\n      return;\n    }\n\n    // redundant checks, including them because of current formatting but want to delete field_name\n    if (field_name === \"minValue\" && updated_var[\"minValue\"] > added_value) {\n      updated_var[\"minValue\"] = added_value;\n    } else if (field_name === \"maxValue\" && updated_var[\"maxValue\"] < added_value) {\n      updated_var[\"maxValue\"] = added_value;\n    }\n  }\n\n  /**\n   * Logic for updating description field that checks to see value already exists. If it does,\n   * appends the pluginType to the current key and pushes that along with the value. Creates\n   * map if it does not exist.\n   *\n   * @private\n   * @param {*} updated_var - The variable to be updated.\n   * @param {*} added_value - The value to be added with the key being the name of the plugin and the key being the description field.\n   */\n  private updateDescription(updated_var, added_value): void {\n    // getting key and value for new value for clarity\n    const add_key = Object.keys(added_value)[0];\n    const add_value = Object.values(added_value)[0];\n\n    if (add_key === \"undefined\" || add_value === \"undefined\") {\n      console.error(\"New value is passed in bad format\", added_value);\n      return;\n    }\n\n    var exists = false;\n    // creates map for description if doesn't exist\n    if (typeof updated_var[\"description\"] !== \"object\") {\n      updated_var[\"description\"] = {};\n    }\n\n    // appends key to other keys if default value/description are the same already exist to keep metadata shorter\n    Object.entries(updated_var[\"description\"]).forEach(([key, value]) => {\n      if (value === add_value) {\n        if (!key.includes(add_key)) {\n          // substring check to see it doesn't exist\n          delete updated_var[\"description\"][key]; // deletes old version\n          updated_var[\"description\"][key + \", \" + add_key] = add_value;\n        }\n        exists = true;\n      }\n    });\n\n    // if value description doesn't exist previous, adds\n    if (!exists) Object.assign(updated_var[\"description\"], added_value); // Assuming added_value is { chatplugin: \"response that user input\" }\n  }\n\n  /**\n   * Logic for updating name. Needs to retain all the old values while creating a new reference in the map\n   * while keeping the same perspe\n   *\n   * @private\n   * @param {*} updated_var\n   * @param {*} added_value\n   */\n  private updateName(updated_var, added_value): void {\n    const old_name = updated_var[\"name\"];\n    updated_var[\"name\"] = added_value;\n    delete this.variables[old_name];\n\n    this.setVariable(updated_var);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name. Returns console error if not found.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    if (var_name in this.variables) {\n      delete this.variables[var_name];\n    } else {\n      console.error(`Variable \"${var_name}\" does not exist.`);\n    }\n  }\n}\n","import { AuthorFields, AuthorsMap } from \"./AuthorsMap\";\nimport { PluginCache } from \"./PluginCache\";\nimport { VariableFields, VariablesMap } from \"./VariablesMap\";\n\n/**\n * Class that handles the storage, update and retrieval of Metadata.\n *\n * @export\n * @class JsPsychMetadata\n * @typedef {JsPsychMetadata}\n */\nexport default class JsPsychMetadata {\n  /**\n   * Field that contains all metadata fields that aren't represented as a list.\n   *\n   * @private\n   * @type {{}}\n   */\n  private metadata: {};\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of author metadata.\n   *\n   * @private\n   * @type {AuthorsMap}\n   */\n  private authors: AuthorsMap;\n  /**;\n   * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n   *\n   * @private\n   * @type {VariablesMap}\n   */\n  private variables: VariablesMap;\n\n  private pluginCache: PluginCache;\n\n  /**\n   * Creates an instance of JsPsychMetadata while passing in JsPsych object to have access to context\n   *  allowing it to access the screen printing information.\n   *\n   * @constructor\n   * @param {JsPsych} JsPsych\n   */\n  constructor() {\n    this.metadata = {};\n    // generates default metadata\n    this.setMetadataField(\"name\", \"title\");\n    this.setMetadataField(\"schemaVersion\", \"Psych-DS 0.4.0\");\n    this.setMetadataField(\"@context\", \"https://schema.org\");\n    this.setMetadataField(\"@type\", \"Dataset\");\n    this.setMetadataField(\"description\", \"Dataset generated using JsPsych\");\n    this.authors = new AuthorsMap();\n    this.variables = new VariablesMap();\n    this.pluginCache = new PluginCache();\n  }\n\n  /**\n   * Method that sets simple metadata fields. This method can also be used to update/overwrite existing fields.\n   *\n   * @param {string} key - Metadata field name\n   * @param {*} value - Data associated with the field\n   */\n  setMetadataField(key: string, value: any): void {\n    this.metadata[key] = value;\n  }\n\n  /**\n   * Simple get that accesses the data associated with a field.\n   *\n   * @param {string} key - Field name\n   * @returns {*} - Data associated with the field\n   */\n  getMetadataField(key: string): any {\n    return this.metadata[key];\n  }\n\n  /**\n   * Returns the final Metadata in a single javascript object. Bundles together the author and variables\n   * together in a list rather than object compliant with Psych-DS standards.\n   *\n   * @returns {{}} - Final Metadata object\n   */\n  getMetadata(): {} {\n    const res = this.metadata;\n    res[\"author\"] = this.authors.getList();\n    res[\"variableMeasured\"] = this.variables.getList();\n\n    return res;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(fields: AuthorFields): void {\n    this.authors.setAuthor(fields); // Assuming `authors` is an instance of the AuthorsMap class\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    return this.authors.getAuthor(name);\n  }\n\n  /**\n   * Method that creates a variable. This method can also be used to overwrite variables with the same name\n   * as a way to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Fields associated with the current Psych-DS standard.\n   */\n  setVariable(variable: VariableFields): void {\n    this.variables.setVariable(variable);\n  }\n\n  /**\n   * Allows you to access a variable's information by using the name of the variable. Can\n   * be used to update fields within a variable, but suggest using updateVariable() to prevent errors.\n   *\n   * @param {string} name - Name of variable to be accessed\n   * @returns {{}} - Returns object of fields\n   */\n  getVariable(name: string): {} {\n    return this.variables.getVariable(name);\n  }\n\n  containsVariable(name: string): boolean {\n    return this.variables.containsVariable(name);\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value.\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Name of field to be updated.\n   * @param {(string | boolean | number | {})} added_value - Value to be used in the update.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    this.variables.updateVariable(var_name, field_name, added_value);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    this.variables.deleteVariable(var_name);\n  }\n\n  /**\n   * Gets a list of all the variable names.\n   *\n   * @returns {string[]} - List of variable string names.\n   */\n  getVariableNames(): string[] {\n    return this.variables.getVariableNames();\n  }\n\n  /**\n   * Method that allows you to display metadata at the end of an experiment.\n   *\n   * @param {string} [elementId=\"jspsych-metadata-display\"] - Id for how to style the metadata. Defaults to default styling.\n   */\n  displayMetadata(display_element) {\n    const elementId = \"jspsych-metadata-display\";\n    const metadata_string = JSON.stringify(this.getMetadata(), null, 2);\n    // const display_element = this.JsPsych.getDisplayElement();\n    display_element.innerHTML += `<p id=\"jspsych-metadata-header\">Metadata</p><pre id=\"${elementId}\" class=\"jspsych-preformat\"></pre>`;\n    document.getElementById(elementId).textContent += metadata_string;\n  }\n\n  /**\n   * Method that begins a download for the dataset_description.json at the end of experiment.\n   * Allows you to download the metadat.\n   */\n  saveAsJsonFile(): void {\n    const jsonString = JSON.stringify(this.getMetadata(), null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"dataset_description.json\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Function to convert string csv into a javascript json object.\n   *\n   * Created by reversing function in datamodule using ChatGPT.\n   *\n   * @private\n   * @param {*} csv - CSV that is represented as string\n   * @returns {*} - Returns a json object\n   */\n  private CSV2JSON(csvString) {\n    const lines = csvString.split(\"\\r\\n\");\n    const result = [];\n    const headers = lines[0].split(\",\").map((header) => header.replace(/\"\"/g, '\"').slice(1, -1));\n\n    for (let i = 1; i < lines.length; i++) {\n      if (!lines[i]) continue; // Skip empty lines\n      const obj = {};\n      const currentLine = lines[i]\n        .split(\",\")\n        .map((value) => value.replace(/\"\"/g, '\"').slice(1, -1));\n\n      headers.forEach((header, index) => {\n        const value = currentLine[index];\n        if (value !== undefined && value !== \"\") {\n          if (!isNaN(value)) {\n            obj[header] = parseFloat(value); // Convert to number if possible\n          } else if (value.toLowerCase() === \"null\") {\n            obj[header] = null; // Set as null if the string is \"null\"\n          } else {\n            try {\n              obj[header] = JSON.parse(value); // Try to parse as JSON (handles objects and arrays)\n            } catch (e) {\n              obj[header] = value; // Use the string value if parsing fails\n            }\n          }\n        }\n        // If value is undefined or empty, skip adding it to the object\n      });\n\n      if (Object.keys(obj).length > 0) {\n        result.push(obj);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Generates observations based on the input data and processes optional metadata.\n   *\n   * This method accepts data, which can be an array of observation objects, a JSON string,\n   * or a CSV string. If the data is in CSV format, set the `csv` parameter to `true` to\n   * parse it into a JSON object. Each observation is processed asynchronously using the\n   * `generateObservation` method. Optionally, metadata can be provided in the form of an\n   * object, and each key-value pair in the metadata object will be processed by the\n   * `processMetadata` method.\n   *\n   * @async\n   * @param {Array|String} data - The data to generate observations from. Can be an array of objects, a JSON string, or a CSV string.\n   * @param {Object} [metadata={}] - Optional metadata to be processed. Each key-value pair in this object will be processed individually.\n   * @param {boolean} [csv=false] - Flag indicating if the data is in a string CSV. If true, the data will be parsed as CSV.\n   */\n  async generate(data, metadata = {}, csv = false) {\n    if (csv) {\n      data = this.CSV2JSON(data);\n    } else if (typeof data === \"string\") {\n      data = JSON.parse(data);\n    }\n\n    if (typeof data !== \"object\") {\n      console.error(\"Unable to parse data object object, not in correct format\");\n      return;\n    }\n\n    for (const observation of data) {\n      await this.generateObservation(observation);\n    }\n\n    for (const key in metadata) {\n      this.processMetadata(metadata, key);\n    }\n  }\n\n  private async generateObservation(observation) {\n    // variables can be thought of mapping of one column in a row\n    const pluginType = observation[\"trial_type\"];\n    const ignored_fields = new Set([\"trial_type\", \"trial_index\", \"time_elapsed\"]);\n\n    for (const variable in observation) {\n      const value = observation[variable];\n      // console.log(\"pluginType:\", pluginType, \"variable:\", variable, \"value:\", value);\n\n      if (value === null) continue;\n\n      if (ignored_fields.has(variable)) this.updateFields(variable, value, typeof value);\n      else await this.generateMetadata(variable, value, pluginType);\n    }\n  }\n\n  private async generateMetadata(variable, value, pluginType) {\n    // probably should work in a call to the plugin here\n    const pluginInfo = await this.getPluginInfo(pluginType, variable);\n    const description = pluginInfo[\"description\"];\n    const new_description = description\n      ? { [pluginType]: description }\n      : { [pluginType]: \"unknown\" };\n    const type = typeof value;\n\n    if (!this.containsVariable(variable)) {\n      // probs should have update description called here\n      const new_var = {\n        type: \"PropertyValue\",\n        name: variable,\n        description: { default: \"unknown\" },\n        value: type,\n      };\n      this.setVariable(new_var);\n    }\n\n    // hit the update variable decription fields\n    this.updateVariable(variable, \"description\", new_description);\n    this.updateFields(variable, value, type);\n  }\n\n  private updateFields(variable, value, type) {\n    // calls updates where updateVariable handles logic\n    if (type === \"number\") {\n      this.updateVariable(variable, \"minValue\", value); // technically can refactor one call to do both but makes confusing\n      this.updateVariable(variable, \"maxValue\", value);\n      return;\n    }\n    // calls updates where updateVariable handles logic\n    if (type !== \"number\" && type !== \"object\") {\n      this.updateVariable(variable, \"levels\", value);\n    }\n  }\n\n  private processMetadata(metadata, key) {\n    const value = metadata[key];\n\n    // iterating through variables metadata\n    if (key === \"variables\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Variable object is either null or incorrect type\");\n        return;\n      }\n\n      // all of the variables must already exist because should have datapoints\n      for (let variable_key in value) {\n        if (!this.containsVariable(variable_key)) {\n          console.warn(\"Metadata does not contain variable:\", variable_key);\n          continue;\n        }\n\n        const variable_parameters = value[variable_key];\n\n        if (typeof variable_parameters !== \"object\" || variable_parameters === null) {\n          console.warn(\n            \"Parameters of variable:\",\n            variable_key,\n            \"is either null or incorrect type. The value\",\n            variable_parameters,\n            \"is either null or not an object.\"\n          );\n          continue;\n        }\n\n        // calling updates for each of the renamed parameters within variable/errors handled by method call\n        for (const parameter in variable_parameters) {\n          const parameter_value = variable_parameters[parameter];\n          this.updateVariable(variable_key, parameter, parameter_value);\n          if (parameter === \"name\") variable_key = parameter_value; // renames future instances if changing name\n        }\n      }\n    } // iterating through each individual author class\n    else if (key === \"author\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Author object is not correct type\");\n        return;\n      }\n\n      for (const author_key in value) {\n        const author = value[author_key];\n\n        if (typeof author !== \"string\" && !(\"name\" in author)) author[\"name\"] = author_key; // handles string case and empty name (uses handle)\n\n        this.setAuthor(author);\n      }\n    } else this.setMetadataField(key, value);\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  // private async getPluginInfo(pluginType: string, variableName: string) {\n  //   const cache_request = this.checkCache(pluginType, variableName);\n  //   if (cache_request) return cache_request;\n\n  //   const description = await this.fetchAPI(pluginType, variableName);\n  //   return description;\n  // }\n\n  private async getPluginInfo(pluginType: string, variableName: string) {\n    return this.pluginCache.getPluginInfo(pluginType, variableName);\n  }\n}\n"],"names":["f","r","u","a","h","s","t","e","d","l","i","AuthorsMap","author_list","key","author","_a","name","rest","__objRest","newAuthor","__spreadValues","unexpectedFields","S","v","F","c","p","n","o","PluginCache","pluginType","variableName","__async","fields","script","unpkgUrl","error","dataString","result","varRegex","propRegex","match","description","varName","props","propsObj","propMatch","propName","propValue","VariablesMap","trial_type_var","trial_index_var","time_elapsed_var","var_list","variable","numKeys","var_name","field_name","added_value","updated_var","add_key","add_value","exists","value","old_name","JsPsychMetadata","res","display_element","elementId","metadata_string","jsonString","blob","url","csvString","lines","headers","header","obj","currentLine","index","_0","data","metadata","csv","observation","ignored_fields","new_description","type","new_var","variable_key","variable_parameters","parameter","parameter_value","author_key"],"mappings":"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"}