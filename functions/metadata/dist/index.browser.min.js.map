{"version":3,"file":"index.browser.min.js","sources":["../src/AuthorsMap.ts","../src/VariablesMap.ts","../src/index.ts"],"sourcesContent":["/**\n * Interface that defines the type for the fields that are specified for authors\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface AuthorFields\n * @typedef {AuthorFields}\n */\nexport interface AuthorFields {\n  /** The type of the author. */\n  type?: string;\n  /** The name of the author. (required) */\n  name: string;\n  /** The given name of the author. */\n  givenName?: string;\n  /** The family name of the author. */\n  familyName?: string;\n  /** The identifier that distinguishes the author across datasets (URL). */\n  identifier?: string;\n}\n\n/**\n * Class that helps keep track of authors and allows for easy conversion to list format when\n * generating the final Metadata file.\n *\n * @export\n * @class AuthorsMap\n * @typedef {AuthorsMap}\n */\nexport class AuthorsMap {\n  /**\n   * Field that keeps track of the authors in a map.\n   *\n   * @private\n   * @type {({ [key: string]: AuthorFields | string })}\n   */\n  private authors: { [key: string]: AuthorFields | string };\n\n  /**\n   * Creates an empty instance of authors map. Doesn't generate default metadata because\n   * can't assume anything about the authors.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.authors = {};\n  }\n\n  /**\n   * Returns the final list format of the authors according to Psych-DS standards.\n   *\n   * @returns {(AuthorFields | string)[]} - List of authors\n   */\n  getList(): (AuthorFields | string)[] {\n    const author_list = [];\n    for (const key of Object.keys(this.authors)) {\n      author_list.push(this.authors[key]);\n    }\n    return author_list;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(author: AuthorFields | string): void {\n    // Handling string input\n    if (typeof author === \"string\") {\n      this.authors[author] = author;\n      return;\n    }\n\n    if (!author.name) {\n      console.warn(\"Name field is missing. Author not added.\");\n      return;\n    }\n\n    const { name, ...rest } = author;\n\n    if (Object.keys(rest).length == 0) {\n      this.authors[name] = name;\n    } else {\n      const newAuthor: AuthorFields = { name, ...rest };\n      this.authors[name] = newAuthor;\n\n      const unexpectedFields = Object.keys(author).filter(\n        (key) => ![\"type\", \"name\", \"givenName\", \"familyName\", \"identifier\"].includes(key)\n      );\n      if (unexpectedFields.length > 0) {\n        console.warn(\n          `Unexpected fields (${unexpectedFields.join(\n            \", \"\n          )}) detected and included in the author object.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    if (name in this.authors) {\n      return this.authors[name];\n    } else {\n      console.warn(\"Author (\", name, \") not found.\");\n      return {};\n    }\n  }\n}\n","/**\n * Interface that defines the type for the fields that are specified for variables\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface VariableFields\n * @typedef {VariableFields}\n */\nexport interface VariableFields {\n  type?: string;\n  name: string; // required\n  description?: string | Record<string, string>;\n  value?: string; // string, boolean, or number\n  identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  minValue?: number;\n  maxValue?: number;\n  levels?: string[] | []; // technically property values in the other one but not sure how to format it\n  levelsOrdered?: boolean;\n  na?: boolean;\n  naValue?: string;\n  alternateName?: string;\n  privacy?: string;\n}\n\n/**\n * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n *\n * @export\n * @class VariablesMap\n * @typedef {VariablesMap}\n */\nexport class VariablesMap {\n  /**\n   * Field that holds a map of the current variables allowing for fast look-up.\n   *\n   * @private\n   * @type {{ [key: string]: VariableFields }}\n   */\n  private variables: { [key: string]: VariableFields };\n\n  /**\n   *  Creates the VariablesMap bycalling generateDefaultVariables() method to\n   * generate the basic metadata common to every dataset_description.json file.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.generateDefaultVariables();\n  }\n\n  /**\n   * Generates the default variables shared between every JsPsych experiment and fills in\n   * with default descriptions according to JsPsych documentation.\n   */\n  generateDefaultVariables(): void {\n    this.variables = {};\n\n    const trial_type_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_type\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The name of the plugin used to run the trial.\",\n      },\n      value: \"string\",\n    };\n    this.setVariable(trial_type_var);\n\n    const trial_index_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_index\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The index of the current trial across the whole experiment.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(trial_index_var);\n\n    const time_elapsed_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"time_elapsed\",\n      description: {\n        default: \"unknown\",\n        jsPsych:\n          \"The number of milliseconds between the start of the experiment and when the trial ended.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(time_elapsed_var);\n  }\n\n  /**\n   * Returns a list of the variables instead of an object according to the Psych-DS format.\n   *\n   * @returns {{}[]} - The list of variables represented as objects.\n   */\n  getList(): {}[] {\n    var var_list = [];\n\n    // need to check that this works as intended\n    for (const key of Object.keys(this.variables)) {\n      const variable = this.variables[key];\n      const description = variable[\"description\"];\n      const numKeys = Object.keys(description).length;\n\n      if (numKeys === 0) console.error(\"Empty description\"); // error: description empty\n      else if (numKeys === 1) {\n        // description becomes single field (assumed to be default)\n        const key = Object.keys(description)[0];\n        variable[\"description\"] = description[key];\n      } else if (numKeys == 2) {\n        delete description[\"default\"]; // deletes default\n\n        if (Object.keys(description).length == 1) {\n          // error checking that it reduced to one key\n          const key = Object.keys(description)[0];\n          variable[\"description\"] = description[key];\n        }\n      } else if (numKeys > 2) {\n        // deletes default\n        delete description[\"default\"];\n      }\n\n      var_list.push(variable);\n    }\n    return var_list;\n  }\n\n  /**\n   * Allows user to set a variable and includes all the fields that are possible according to\n   * Psych-DS guidelines. Only requires the name field which it uses a key to map to the variable.\n   * Can also be used to overwrite existing variables if they have the same name.\n   *\n   * @param {VariableFields} variable - The fields of the variable that is being created.\n   */\n  setVariable(variable: VariableFields): void {\n    if (!variable.name) {\n      // Ensure name is provided\n      console.warn(\"Name field is missing. Variable not added.\", variable);\n      return;\n    }\n\n    this.variables[variable.name] = variable;\n\n    const unexpectedFields = Object.keys(variable).filter(\n      (key) =>\n        ![\n          \"type\",\n          \"name\",\n          \"description\",\n          \"value\",\n          \"identifier\",\n          \"minValue\",\n          \"maxValue\",\n          \"levels\",\n          \"levelsOrdered\",\n          \"na\",\n          \"naValue\",\n          \"alternateName\",\n          \"privacy\",\n        ].includes(key)\n    );\n    if (unexpectedFields.length > 0) {\n      console.warn(\n        `Unexpected fields (${unexpectedFields.join(\n          \", \"\n        )}) detected and included in the variable object.`\n      );\n    }\n  }\n\n  /**\n   * Allows you to get information for a single variable returning empty dict if it doesn't exist.\n   * Allows you to update fields but not recommended in favor of updateVariable.\n   *\n   * @param {string} name\n   * @returns {(VariableFields | {})} - Variable information or empty dict if doesn't exist\n   */\n  getVariable(name: string): VariableFields | {} {\n    return this.variables[name] || {};\n  }\n\n  /**\n   * Checks if variable exists in VariablesMap.\n   *\n   * @param {string} name - Name of variable\n   * @returns {boolean} - True if exists, false if doesn't.\n   */\n  containsVariable(name: string): boolean {\n    return name in this.variables;\n  }\n\n  /**\n   * Method that gets a list of the names of variables.\n   *\n   * @returns {string[]} - String list containing names of existing variables.\n   */\n  getVariableNames(): string[] {\n    var var_list = [];\n    for (const key of Object.keys(this.variables)) {\n      var_list.push(this.variables[key][\"name\"]);\n    }\n\n    return var_list;\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value. Has special cases and logic for levels and names making it\n   * easier to update variable values.\n   *\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Specific field to be updated.\n   * @param {(string | boolean | number | { [key: string]: string })} added_value - Single value to be updated, with a mapping if adding to description with key representing pluginType.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | { [key: string]: string }\n  ): void {\n    const updated_var = this.getVariable(var_name);\n\n    if (Object.keys(updated_var).length === 0) {\n      // error checking to see variable exists\n      console.error(`Variable \"${var_name}\" does not exist.`);\n      return;\n    }\n\n    if (field_name === \"levels\") {\n      this.updateLevels(updated_var, added_value);\n    } else if (field_name === \"minValue\" || field_name === \"maxValue\") {\n      this.updateMinMax(updated_var, added_value, field_name);\n    } else if (field_name === \"description\") {\n      this.updateDescription(updated_var, added_value);\n    } else if (field_name === \"name\") {\n      this.updateName(updated_var, added_value);\n    } else {\n      updated_var[field_name] = added_value;\n    }\n  }\n\n  /**\n   * Logic that handles updates to levels field by creating new array if necessary, otherwise\n   * pushing the value if it doesn't already exist. Levels can only be added to with strings.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value being added to the levels field.\n   */\n  private updateLevels(updated_var, added_value): void {\n    if (!Array.isArray(updated_var[\"levels\"])) {\n      updated_var[\"levels\"] = [];\n    }\n    if (!updated_var[\"levels\"].includes(added_value)) {\n      updated_var[\"levels\"].push(added_value);\n    }\n  }\n\n  /**\n   * Logic to update the min and max for the specific value.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value that is being checked against current min/max.\n   * @param {*} field_name - The name of field that is being checked (min or max).\n   */\n  private updateMinMax(updated_var, added_value, field_name): void {\n    // check if min or max\n    if (!(\"minValue\" in updated_var) || !(\"maxValue\" in updated_var)) {\n      updated_var[\"maxValue\"] = updated_var[\"minValue\"] = added_value;\n      return;\n    }\n\n    // redundant checks, including them because of current formatting but want to delete field_name\n    if (field_name === \"minValue\" && updated_var[\"minValue\"] > added_value) {\n      updated_var[\"minValue\"] = added_value;\n    } else if (field_name === \"maxValue\" && updated_var[\"maxValue\"] < added_value) {\n      updated_var[\"maxValue\"] = added_value;\n    }\n  }\n\n  /**\n   * Logic for updating description field that checks to see value already exists. If it does,\n   * appends the pluginType to the current key and pushes that along with the value. Creates\n   * map if it does not exist.\n   *\n   * @private\n   * @param {*} updated_var - The variable to be updated.\n   * @param {*} added_value - The value to be added with the key being the name of the plugin and the key being the description field.\n   */\n  private updateDescription(updated_var, added_value): void {\n    // getting key and value for new value for clarity\n    const add_key = Object.keys(added_value)[0];\n    const add_value = Object.values(added_value)[0];\n\n    if (add_key === \"undefined\" || add_value === \"undefined\") {\n      console.error(\"New value is passed in bad format\", added_value);\n      return;\n    }\n\n    var exists = false;\n    // creates map for description if doesn't exist\n    if (typeof updated_var[\"description\"] !== \"object\") {\n      updated_var[\"description\"] = {};\n    }\n\n    // appends key to other keys if default value/description are the same already exist to keep metadata shorter\n    Object.entries(updated_var[\"description\"]).forEach(([key, value]) => {\n      if (value === add_value) {\n        if (!key.includes(add_key)) {\n          // substring check to see it doesn't exist\n          delete updated_var[\"description\"][key]; // deletes old version\n          updated_var[\"description\"][key + \", \" + add_key] = add_value;\n        }\n        exists = true;\n      }\n    });\n\n    // if value description doesn't exist previous, adds\n    if (!exists) Object.assign(updated_var[\"description\"], added_value); // Assuming added_value is { chatplugin: \"response that user input\" }\n  }\n\n  /**\n   * Logic for updating name. Needs to retain all the old values while creating a new reference in the map\n   * while keeping the same perspe\n   *\n   * @private\n   * @param {*} updated_var\n   * @param {*} added_value\n   */\n  private updateName(updated_var, added_value): void {\n    const old_name = updated_var[\"name\"];\n    updated_var[\"name\"] = added_value;\n    delete this.variables[old_name];\n\n    this.setVariable(updated_var);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name. Returns console error if not found.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    if (var_name in this.variables) {\n      delete this.variables[var_name];\n    } else {\n      console.error(`Variable \"${var_name}\" does not exist.`);\n    }\n  }\n}\n","import { AuthorFields } from \"./AuthorsMap\";\nimport { AuthorsMap } from \"./AuthorsMap\";\nimport { VariableFields } from \"./VariablesMap\";\nimport { VariablesMap } from \"./VariablesMap\";\n\n/**\n * Class that handles the storage, update and retrieval of Metadata.\n *\n * @export\n * @class JsPsychMetadata\n * @typedef {JsPsychMetadata}\n */\nexport default class JsPsychMetadata {\n  /**\n   * Field that contains all metadata fields that aren't represented as a list.\n   *\n   * @private\n   * @type {{}}\n   */\n  private metadata: {};\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of author metadata.\n   *\n   * @private\n   * @type {AuthorsMap}\n   */\n  private authors: AuthorsMap;\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n   *\n   * @private\n   * @type {VariablesMap}\n   */\n  private variables: VariablesMap;\n\n  /** The cache is a dictionary of dictionaries, with the outer dictionary keyed by type of plugin\n   * and the inner dictionary keyed by variableName. This is so that even if we have two variables\n   * with the same name in different plugins, we can store their descriptions separately.\n   * @private\n   * @type {{}}\n   */\n  private cache: {};\n  private requests_cache: {}; // temporary requests cache before implementing faster method\n\n  /**\n   * Creates an instance of JsPsychMetadata while passing in JsPsych object to have access to context\n   *  allowing it to access the screen printing information.\n   *\n   * @constructor\n   * @param {JsPsych} JsPsych\n   */\n  constructor() {\n    this.generateDefaultMetadata();\n  }\n  /**\n   * Method that fills in JsPsychMetadata class with all the universal fields with default information.\n   * This is automatically called whenever creating an instance of JsPsychMetadata and indicates all\n   * the required fields that need to filled in to be Psych-DS compliant.\n   */\n  generateDefaultMetadata(): void {\n    this.metadata = {};\n    this.setMetadataField(\"name\", \"title\");\n    this.setMetadataField(\"schemaVersion\", \"Psych-DS 0.4.0\");\n    this.setMetadataField(\"@context\", \"https://schema.org\");\n    this.setMetadataField(\"@type\", \"Dataset\");\n    this.setMetadataField(\"description\", \"Dataset generated using JsPsych\");\n    this.authors = new AuthorsMap();\n    this.variables = new VariablesMap();\n    this.cache = {};\n    this.requests_cache = {};\n  }\n\n  /**\n   * Method that sets simple metadata fields. This method can also be used to update/overwrite existing fields.\n   *\n   * @param {string} key - Metadata field name\n   * @param {*} value - Data associated with the field\n   */\n  setMetadataField(key: string, value: any): void {\n    this.metadata[key] = value;\n  }\n\n  /**\n   * Simple get that accesses the data associated with a field.\n   *\n   * @param {string} key - Field name\n   * @returns {*} - Data associated with the field\n   */\n  getMetadataField(key: string): any {\n    return this.metadata[key];\n  }\n\n  /**\n   * Returns the final Metadata in a single javascript object. Bundles together the author and variables\n   * together in a list rather than object compliant with Psych-DS standards.\n   *\n   * @returns {{}} - Final Metadata object\n   */\n  getMetadata(): {} {\n    const res = this.metadata;\n    res[\"author\"] = this.authors.getList();\n    res[\"variableMeasured\"] = this.variables.getList();\n\n    return res;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(fields: AuthorFields): void {\n    this.authors.setAuthor(fields); // Assuming `authors` is an instance of the AuthorsMap class\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    return this.authors.getAuthor(name);\n  }\n\n  /**\n   * Method that creates a variable. This method can also be used to overwrite variables with the same name\n   * as a way to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Fields associated with the current Psych-DS standard.\n   */\n  setVariable(variable: VariableFields): void {\n    this.variables.setVariable(variable);\n  }\n\n  /**\n   * Allows you to access a variable's information by using the name of the variable. Can\n   * be used to update fields within a variable, but suggest using updateVariable() to prevent errors.\n   *\n   * @param {string} name - Name of variable to be accessed\n   * @returns {{}} - Returns object of fields\n   */\n  getVariable(name: string): {} {\n    return this.variables.getVariable(name);\n  }\n\n  containsVariable(name: string): boolean {\n    return this.variables.containsVariable(name);\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value.\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Name of field to be updated.\n   * @param {(string | boolean | number | {})} added_value - Value to be used in the update.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    this.variables.updateVariable(var_name, field_name, added_value);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    this.variables.deleteVariable(var_name);\n  }\n\n  /**\n   * Gets a list of all the variable names.\n   *\n   * @returns {string[]} - List of variable string names.\n   */\n  getVariableNames(): string[] {\n    return this.variables.getVariableNames();\n  }\n\n  /**\n   * Method that allows you to display metadata at the end of an experiment.\n   *\n   * @param {string} [elementId=\"jspsych-metadata-display\"] - Id for how to style the metadata. Defaults to default styling.\n   */\n  displayMetadata(display_element) {\n    const elementId = \"jspsych-metadata-display\";\n    const metadata_string = JSON.stringify(this.getMetadata(), null, 2);\n    // const display_element = this.JsPsych.getDisplayElement();\n    display_element.innerHTML += `<p id=\"jspsych-metadata-header\">Metadata</p><pre id=\"${elementId}\" class=\"jspsych-preformat\"></pre>`;\n    document.getElementById(elementId).textContent += metadata_string;\n  }\n\n  /**\n   * Method that begins a download for the dataset_description.json at the end of experiment.\n   * Allows you to download the metadat.\n   */\n  saveAsJsonFile(): void {\n    const jsonString = JSON.stringify(this.getMetadata(), null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"dataset_description.json\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Function to convert string csv into a javascript json object.\n   *\n   * Created by reversing function in datamodule using ChatGPT.\n   *\n   * @private\n   * @param {*} csv - CSV that is represented as string\n   * @returns {*} - Returns a json object\n   */\n  private CSV2JSON(csvString) {\n    const lines = csvString.split(\"\\r\\n\");\n    const result = [];\n    const headers = lines[0].split(\",\").map((header) => header.replace(/\"\"/g, '\"').slice(1, -1));\n\n    for (let i = 1; i < lines.length; i++) {\n      if (!lines[i]) continue; // Skip empty lines\n      const obj = {};\n      const currentLine = lines[i]\n        .split(\",\")\n        .map((value) => value.replace(/\"\"/g, '\"').slice(1, -1));\n\n      headers.forEach((header, index) => {\n        const value = currentLine[index];\n        if (value !== undefined && value !== \"\") {\n          if (!isNaN(value)) {\n            obj[header] = parseFloat(value); // Convert to number if possible\n          } else if (value.toLowerCase() === \"null\") {\n            obj[header] = null; // Set as null if the string is \"null\"\n          } else {\n            try {\n              obj[header] = JSON.parse(value); // Try to parse as JSON (handles objects and arrays)\n            } catch (e) {\n              obj[header] = value; // Use the string value if parsing fails\n            }\n          }\n        }\n        // If value is undefined or empty, skip adding it to the object\n      });\n\n      if (Object.keys(obj).length > 0) {\n        result.push(obj);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Generates observations based on the input data and processes optional metadata.\n   *\n   * This method accepts data, which can be an array of observation objects, a JSON string,\n   * or a CSV string. If the data is in CSV format, set the `csv` parameter to `true` to\n   * parse it into a JSON object. Each observation is processed asynchronously using the\n   * `generateObservation` method. Optionally, metadata can be provided in the form of an\n   * object, and each key-value pair in the metadata object will be processed by the\n   * `processMetadata` method.\n   *\n   * @async\n   * @param {Array|String} data - The data to generate observations from. Can be an array of objects, a JSON string, or a CSV string.\n   * @param {Object} [metadata={}] - Optional metadata to be processed. Each key-value pair in this object will be processed individually.\n   * @param {boolean} [csv=false] - Flag indicating if the data is in a string CSV. If true, the data will be parsed as CSV.\n   */\n  async generate(data, metadata = {}, csv = false) {\n    if (csv) {\n      data = this.CSV2JSON(data);\n    } else if (typeof data === \"string\") {\n      data = JSON.parse(data);\n    }\n\n    if (typeof data !== \"object\") {\n      console.error(\"Unable to parse data object object, not in correct format\");\n      return;\n    }\n\n    for (const observation of data) {\n      await this.generateObservation(observation);\n    }\n\n    for (const key in metadata) {\n      this.processMetadata(metadata, key);\n    }\n  }\n\n  private async generateObservation(observation) {\n    // variables can be thought of mapping of one column in a row\n    const pluginType = observation[\"trial_type\"];\n    const ignored_fields = new Set([\"trial_type\", \"trial_index\", \"time_elapsed\"]);\n\n    for (const variable in observation) {\n      const value = observation[variable];\n\n      if (value === null) continue;\n\n      if (ignored_fields.has(variable)) this.updateFields(variable, value, typeof value);\n      else await this.generateMetadata(variable, value, pluginType);\n    }\n  }\n\n  private async generateMetadata(variable, value, pluginType) {\n    // probably should work in a call to the plugin here\n    const description = await this.getPluginInfo(pluginType, variable);\n    const new_description = description\n      ? { [pluginType]: description }\n      : { [pluginType]: \"unknown\" };\n    const type = typeof value;\n\n    if (!this.containsVariable(variable)) {\n      // probs should have update description called here\n      const new_var = {\n        type: \"PropertyValue\",\n        name: variable,\n        description: { default: \"unknown\" },\n        value: type,\n      };\n      this.setVariable(new_var);\n    }\n\n    // hit the update variable decription fields\n    this.updateVariable(variable, \"description\", new_description);\n    this.updateFields(variable, value, type);\n  }\n\n  private updateFields(variable, value, type) {\n    // calls updates where updateVariable handles logic\n    if (type === \"number\") {\n      this.updateVariable(variable, \"minValue\", value); // technically can refactor one call to do both but makes confusing\n      this.updateVariable(variable, \"maxValue\", value);\n      return;\n    }\n    // calls updates where updateVariable handles logic\n    if (type !== \"number\" && type !== \"object\") {\n      this.updateVariable(variable, \"levels\", value);\n    }\n  }\n\n  private processMetadata(metadata, key) {\n    const value = metadata[key];\n\n    // iterating through variables metadata\n    if (key === \"variables\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Variable object is either null or incorrect type\");\n        return;\n      }\n\n      // all of the variables must already exist because should have datapoints\n      for (let variable_key in value) {\n        if (!this.containsVariable(variable_key)) {\n          console.warn(\"Metadata does not contain variable:\", variable_key);\n          continue;\n        }\n\n        const variable_parameters = value[variable_key];\n\n        if (typeof variable_parameters !== \"object\" || variable_parameters === null) {\n          console.warn(\n            \"Parameters of variable:\",\n            variable_key,\n            \"is either null or incorrect type. The value\",\n            variable_parameters,\n            \"is either null or not an object.\"\n          );\n          continue;\n        }\n\n        // calling updates for each of the renamed parameters within variable/errors handled by method call\n        for (const parameter in variable_parameters) {\n          const parameter_value = variable_parameters[parameter];\n          this.updateVariable(variable_key, parameter, parameter_value);\n          if (parameter === \"name\") variable_key = parameter_value; // renames future instances if changing name\n        }\n      }\n    } // iterating through each individual author class\n    else if (key === \"author\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Author object is not correct type\");\n        return;\n      }\n\n      for (const author_key in value) {\n        const author = value[author_key];\n\n        if (typeof author !== \"string\" && !(\"name\" in author)) author[\"name\"] = author_key; // handles string case and empty name (uses handle)\n\n        this.setAuthor(author);\n      }\n    } else this.setMetadataField(key, value);\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  private async getPluginInfo(pluginType: string, variableName: string) {\n    // Check if the cache for the pluginType exists, if not initialize it\n    if (!this.cache[pluginType]) this.cache[pluginType] = {};\n    else if (variableName in this.cache[pluginType]) {\n      // If the variable already exists in the cache for the plugin, return the cached value\n      return this.cache[pluginType][variableName];\n    }\n\n    // If not, we proceed to fetch script:\n    // Construct the URL for the unpkg service\n    const unpkgUrl = `https://unpkg.com/@jspsych/plugin-${pluginType}/src/index.ts`;\n\n    try {\n      let description = \"unknown\";\n      // check requests cache\n      if (pluginType in this.requests_cache) {\n        const scriptContent = this.requests_cache[pluginType];\n        description = this.getJsdocsDescription(scriptContent, variableName);\n        this.cache[pluginType][variableName] = description;\n      } else {\n        // Fetch the script content from the unpkg URL\n        const response = await fetch(unpkgUrl);\n        const scriptContent = await response.text();\n        this.requests_cache[pluginType] = scriptContent;\n        console.log(scriptContent);\n\n        // Extract the JSDoc description for the variable from the script content\n        description = this.getJsdocsDescription(scriptContent, variableName);\n\n        // Check again if the cache for the pluginType exists, if not initialize it\n        if (!this.cache[pluginType]) this.cache[pluginType] = {}; // don't think this ever returns true, might be able delete\n\n        // Cache the description for the variable in the pluginType cache\n        this.cache[pluginType][variableName] = description;\n        // Return the description\n      }\n\n      return description;\n    } catch (error) {\n      console.error(`Failed to fetch info from ${unpkgUrl}:`, error); // DISABLING to test other features\n      // Error is likely due to 1)a fetch failure, or 2)no JSDoc comments in the script content matched.\n      //HANDLE FETCH FAILURE CASES\n      // In case of the latter, we cache the null value to prevent repeated fetch attempts.\n\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      this.cache[pluginType][variableName] = null;\n\n      return \"failed with error\";\n    }\n  }\n\n  /**\n   * Extracts the description for a variable of a plugin from the JSDoc comments present in the script of the plugin. The script content is\n   * drawn from the remotely hosted source file of the plugin through getPluginInfo. The script content is taken\n   * as a string and Regex is used to extract the description.\n   *\n   *\n   * @param {string} scriptContent - The content of the script from which the JSDoc description is to be extracted.\n   * @param {string} variableName - The name of the variable for which the JSDoc description is to be extracted.\n   * @returns {string} The extracted JSDoc description, cleaned and trimmed.\n   */\n  private getJsdocsDescription(scriptContent: string, variableName: string) {\n    // Regex to match part of the content that starts with 'parameters:' and ends with '};', which\n    // is parameters info. THIS MUST BE CHANGED TO data FOR NEW PLUGIN LAYOUT\n    const paramRegex = scriptContent.match(/parameters:\\s*{([\\s\\S]*?)};\\s*/).join();\n\n    // Regex that matches everything up to the variable name\n    const regex = new RegExp(`((.|\\n)*)(?=${variableName}:)`);\n\n    // Regex on paramRegex, to get everything from 'paramaters:' to the variable name.\n    const variableRegex = paramRegex.match(regex)[0];\n\n    // Finds the index of the last occurence of `/**` in the variableRegex string, and slices it from there\n    // to give the JSDoc comment for our variable.\n    const descrip = variableRegex.slice(variableRegex.lastIndexOf(\"/**\"));\n\n    // Regex to remove the leading and trailing '/**' and '*/' characters.\n    const clean = descrip.match(/(?<=\\*\\*)([\\s\\S]*?)(?=\\*\\/)/)[1];\n\n    //CLEANING:\n    // Regex to remove all newline characters.\n    const cleaner = clean.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n    // Remove all '*' characters from the JSDoc comment.\n    const cleanest = cleaner.replace(/\\*/gm, \"\");\n\n    // Return the cleaned JSDoc comment, trimmed of leading and trailing whitespace\n    return cleanest.trim();\n  }\n}\n"],"names":["f","r","u","a","h","s","t","e","d","l","i","AuthorsMap","author_list","key","author","_a","name","rest","__objRest","newAuthor","__spreadValues","unexpectedFields","VariablesMap","trial_type_var","trial_index_var","time_elapsed_var","var_list","variable","description","numKeys","var_name","field_name","added_value","updated_var","add_key","add_value","exists","value","old_name","n","JsPsychMetadata","res","fields","display_element","elementId","metadata_string","jsonString","blob","url","csvString","lines","result","headers","header","obj","currentLine","index","_0","__async","data","metadata","csv","observation","pluginType","ignored_fields","new_description","type","new_var","variable_key","variable_parameters","parameter","parameter_value","author_key","variableName","unpkgUrl","scriptContent","error","paramRegex","regex","variableRegex"],"mappings":"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"}