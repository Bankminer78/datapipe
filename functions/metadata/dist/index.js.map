{"version":3,"file":"index.js","sources":["../src/AuthorsMap.ts","../src/VariablesMap.ts","../src/index.ts"],"sourcesContent":["/**\n * Interface that defines the type for the fields that are specified for authors\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface AuthorFields\n * @typedef {AuthorFields}\n */\nexport interface AuthorFields {\n  /** The type of the author. */\n  type?: string;\n  /** The name of the author. (required) */\n  name: string;\n  /** The given name of the author. */\n  givenName?: string;\n  /** The family name of the author. */\n  familyName?: string;\n  /** The identifier that distinguishes the author across datasets (URL). */\n  identifier?: string;\n}\n\n/**\n * Class that helps keep track of authors and allows for easy conversion to list format when\n * generating the final Metadata file.\n *\n * @export\n * @class AuthorsMap\n * @typedef {AuthorsMap}\n */\nexport class AuthorsMap {\n  /**\n   * Field that keeps track of the authors in a map.\n   *\n   * @private\n   * @type {({ [key: string]: AuthorFields | string })}\n   */\n  private authors: { [key: string]: AuthorFields | string };\n\n  /**\n   * Creates an empty instance of authors map. Doesn't generate default metadata because\n   * can't assume anything about the authors.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.authors = {};\n  }\n\n  /**\n   * Returns the final list format of the authors according to Psych-DS standards.\n   *\n   * @returns {(AuthorFields | string)[]} - List of authors\n   */\n  getList(): (AuthorFields | string)[] {\n    const author_list = [];\n    for (const key of Object.keys(this.authors)) {\n      author_list.push(this.authors[key]);\n    }\n    return author_list;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(author: AuthorFields | string): void {\n    // Handling string input\n    if (typeof author === \"string\") {\n      this.authors[author] = author;\n      return;\n    }\n\n    if (!author.name) {\n      console.warn(\"Name field is missing. Author not added.\");\n      return;\n    }\n\n    const { name, ...rest } = author;\n\n    if (Object.keys(rest).length == 0) {\n      this.authors[name] = name;\n    } else {\n      const newAuthor: AuthorFields = { name, ...rest };\n      this.authors[name] = newAuthor;\n\n      const unexpectedFields = Object.keys(author).filter(\n        (key) => ![\"type\", \"name\", \"givenName\", \"familyName\", \"identifier\"].includes(key)\n      );\n      if (unexpectedFields.length > 0) {\n        console.warn(\n          `Unexpected fields (${unexpectedFields.join(\n            \", \"\n          )}) detected and included in the author object.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    if (name in this.authors) {\n      return this.authors[name];\n    } else {\n      console.warn(\"Author (\", name, \") not found.\");\n      return {};\n    }\n  }\n}\n","/**\n * Interface that defines the type for the fields that are specified for variables\n * according to Psych-DS regulations, with name being the one required field.\n *\n * @export\n * @interface VariableFields\n * @typedef {VariableFields}\n */\nexport interface VariableFields {\n  type?: string;\n  name: string; // required\n  description?: string | Record<string, string>;\n  value?: string; // string, boolean, or number\n  identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  minValue?: number;\n  maxValue?: number;\n  levels?: string[] | []; // technically property values in the other one but not sure how to format it\n  levelsOrdered?: boolean;\n  na?: boolean;\n  naValue?: string;\n  alternateName?: string;\n  privacy?: string;\n}\n\n/**\n * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n *\n * @export\n * @class VariablesMap\n * @typedef {VariablesMap}\n */\nexport class VariablesMap {\n  /**\n   * Field that holds a map of the current variables allowing for fast look-up.\n   *\n   * @private\n   * @type {{ [key: string]: VariableFields }}\n   */\n  private variables: { [key: string]: VariableFields };\n\n  /**\n   *  Creates the VariablesMap bycalling generateDefaultVariables() method to\n   * generate the basic metadata common to every dataset_description.json file.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.generateDefaultVariables();\n  }\n\n  /**\n   * Generates the default variables shared between every JsPsych experiment and fills in\n   * with default descriptions according to JsPsych documentation.\n   */\n  generateDefaultVariables(): void {\n    this.variables = {};\n\n    const trial_type_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_type\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The name of the plugin used to run the trial.\",\n      },\n      value: \"string\",\n    };\n    this.setVariable(trial_type_var);\n\n    const trial_index_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"trial_index\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The index of the current trial across the whole experiment.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(trial_index_var);\n\n    const time_elapsed_var: VariableFields = {\n      type: \"PropertyValue\",\n      name: \"time_elapsed\",\n      description: {\n        default: \"unknown\",\n        jsPsych:\n          \"The number of milliseconds between the start of the experiment and when the trial ended.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(time_elapsed_var);\n  }\n\n  /**\n   * Returns a list of the variables instead of an object according to the Psych-DS format.\n   *\n   * @returns {{}[]} - The list of variables represented as objects.\n   */\n  getList(): {}[] {\n    var var_list = [];\n\n    // need to check that this works as intended\n    for (const key of Object.keys(this.variables)) {\n      const variable = this.variables[key];\n      const description = variable[\"description\"];\n      const numKeys = Object.keys(description).length;\n\n      if (numKeys === 0) console.error(\"Empty description\"); // error: description empty\n      else if (numKeys === 1) {\n        // description becomes single field (assumed to be default)\n        const key = Object.keys(description)[0];\n        variable[\"description\"] = description[key];\n      } else if (numKeys == 2) {\n        delete description[\"default\"]; // deletes default\n\n        if (Object.keys(description).length == 1) {\n          // error checking that it reduced to one key\n          const key = Object.keys(description)[0];\n          variable[\"description\"] = description[key];\n        }\n      } else if (numKeys > 2) {\n        // deletes default\n        delete description[\"default\"];\n      }\n\n      var_list.push(variable);\n    }\n    return var_list;\n  }\n\n  /**\n   * Allows user to set a variable and includes all the fields that are possible according to\n   * Psych-DS guidelines. Only requires the name field which it uses a key to map to the variable.\n   * Can also be used to overwrite existing variables if they have the same name.\n   *\n   * @param {VariableFields} variable - The fields of the variable that is being created.\n   */\n  setVariable(variable: VariableFields): void {\n    if (!variable.name) {\n      // Ensure name is provided\n      console.warn(\"Name field is missing. Variable not added.\", variable);\n      return;\n    }\n\n    this.variables[variable.name] = variable;\n\n    const unexpectedFields = Object.keys(variable).filter(\n      (key) =>\n        ![\n          \"type\",\n          \"name\",\n          \"description\",\n          \"value\",\n          \"identifier\",\n          \"minValue\",\n          \"maxValue\",\n          \"levels\",\n          \"levelsOrdered\",\n          \"na\",\n          \"naValue\",\n          \"alternateName\",\n          \"privacy\",\n        ].includes(key)\n    );\n    if (unexpectedFields.length > 0) {\n      console.warn(\n        `Unexpected fields (${unexpectedFields.join(\n          \", \"\n        )}) detected and included in the variable object.`\n      );\n    }\n  }\n\n  /**\n   * Allows you to get information for a single variable returning empty dict if it doesn't exist.\n   * Allows you to update fields but not recommended in favor of updateVariable.\n   *\n   * @param {string} name\n   * @returns {(VariableFields | {})} - Variable information or empty dict if doesn't exist\n   */\n  getVariable(name: string): VariableFields | {} {\n    return this.variables[name] || {};\n  }\n\n  /**\n   * Checks if variable exists in VariablesMap.\n   *\n   * @param {string} name - Name of variable\n   * @returns {boolean} - True if exists, false if doesn't.\n   */\n  containsVariable(name: string): boolean {\n    return name in this.variables;\n  }\n\n  /**\n   * Method that gets a list of the names of variables.\n   *\n   * @returns {string[]} - String list containing names of existing variables.\n   */\n  getVariableNames(): string[] {\n    var var_list = [];\n    for (const key of Object.keys(this.variables)) {\n      var_list.push(this.variables[key][\"name\"]);\n    }\n\n    return var_list;\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value. Has special cases and logic for levels and names making it\n   * easier to update variable values.\n   *\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Specific field to be updated.\n   * @param {(string | boolean | number | { [key: string]: string })} added_value - Single value to be updated, with a mapping if adding to description with key representing pluginType.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | { [key: string]: string }\n  ): void {\n    const updated_var = this.getVariable(var_name);\n\n    if (Object.keys(updated_var).length === 0) {\n      // error checking to see variable exists\n      console.error(`Variable \"${var_name}\" does not exist.`);\n      return;\n    }\n\n    if (field_name === \"levels\") {\n      this.updateLevels(updated_var, added_value);\n    } else if (field_name === \"minValue\" || field_name === \"maxValue\") {\n      this.updateMinMax(updated_var, added_value, field_name);\n    } else if (field_name === \"description\") {\n      this.updateDescription(updated_var, added_value);\n    } else if (field_name === \"name\") {\n      this.updateName(updated_var, added_value);\n    } else {\n      updated_var[field_name] = added_value;\n    }\n  }\n\n  /**\n   * Logic that handles updates to levels field by creating new array if necessary, otherwise\n   * pushing the value if it doesn't already exist. Levels can only be added to with strings.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value being added to the levels field.\n   */\n  private updateLevels(updated_var, added_value): void {\n    if (!Array.isArray(updated_var[\"levels\"])) {\n      updated_var[\"levels\"] = [];\n    }\n    if (!updated_var[\"levels\"].includes(added_value)) {\n      updated_var[\"levels\"].push(added_value);\n    }\n  }\n\n  /**\n   * Logic to update the min and max for the specific value.\n   *\n   * @private\n   * @param {*} updated_var - The variable object to be updated.\n   * @param {*} added_value - The value that is being checked against current min/max.\n   * @param {*} field_name - The name of field that is being checked (min or max).\n   */\n  private updateMinMax(updated_var, added_value, field_name): void {\n    // check if min or max\n    if (!(\"minValue\" in updated_var) || !(\"maxValue\" in updated_var)) {\n      updated_var[\"maxValue\"] = updated_var[\"minValue\"] = added_value;\n      return;\n    }\n\n    // redundant checks, including them because of current formatting but want to delete field_name\n    if (field_name === \"minValue\" && updated_var[\"minValue\"] > added_value) {\n      updated_var[\"minValue\"] = added_value;\n    } else if (field_name === \"maxValue\" && updated_var[\"maxValue\"] < added_value) {\n      updated_var[\"maxValue\"] = added_value;\n    }\n  }\n\n  /**\n   * Logic for updating description field that checks to see value already exists. If it does,\n   * appends the pluginType to the current key and pushes that along with the value. Creates\n   * map if it does not exist.\n   *\n   * @private\n   * @param {*} updated_var - The variable to be updated.\n   * @param {*} added_value - The value to be added with the key being the name of the plugin and the key being the description field.\n   */\n  private updateDescription(updated_var, added_value): void {\n    // getting key and value for new value for clarity\n    const add_key = Object.keys(added_value)[0];\n    const add_value = Object.values(added_value)[0];\n\n    if (add_key === \"undefined\" || add_value === \"undefined\") {\n      console.error(\"New value is passed in bad format\", added_value);\n      return;\n    }\n\n    var exists = false;\n    // creates map for description if doesn't exist\n    if (typeof updated_var[\"description\"] !== \"object\") {\n      updated_var[\"description\"] = {};\n    }\n\n    // appends key to other keys if default value/description are the same already exist to keep metadata shorter\n    Object.entries(updated_var[\"description\"]).forEach(([key, value]) => {\n      if (value === add_value) {\n        if (!key.includes(add_key)) {\n          // substring check to see it doesn't exist\n          delete updated_var[\"description\"][key]; // deletes old version\n          updated_var[\"description\"][key + \", \" + add_key] = add_value;\n        }\n        exists = true;\n      }\n    });\n\n    // if value description doesn't exist previous, adds\n    if (!exists) Object.assign(updated_var[\"description\"], added_value); // Assuming added_value is { chatplugin: \"response that user input\" }\n  }\n\n  /**\n   * Logic for updating name. Needs to retain all the old values while creating a new reference in the map\n   * while keeping the same perspe\n   *\n   * @private\n   * @param {*} updated_var\n   * @param {*} added_value\n   */\n  private updateName(updated_var, added_value): void {\n    const old_name = updated_var[\"name\"];\n    updated_var[\"name\"] = added_value;\n    delete this.variables[old_name];\n\n    this.setVariable(updated_var);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name. Returns console error if not found.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    if (var_name in this.variables) {\n      delete this.variables[var_name];\n    } else {\n      console.error(`Variable \"${var_name}\" does not exist.`);\n    }\n  }\n}\n","import { AuthorFields } from \"./AuthorsMap\";\nimport { AuthorsMap } from \"./AuthorsMap\";\nimport { VariableFields } from \"./VariablesMap\";\nimport { VariablesMap } from \"./VariablesMap\";\n\n/**\n * Class that handles the storage, update and retrieval of Metadata.\n *\n * @export\n * @class JsPsychMetadata\n * @typedef {JsPsychMetadata}\n */\nexport default class JsPsychMetadata {\n  /**\n   * Field that contains all metadata fields that aren't represented as a list.\n   *\n   * @private\n   * @type {{}}\n   */\n  private metadata: {};\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of author metadata.\n   *\n   * @private\n   * @type {AuthorsMap}\n   */\n  private authors: AuthorsMap;\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n   *\n   * @private\n   * @type {VariablesMap}\n   */\n  private variables: VariablesMap;\n\n  /** The cache is a dictionary of dictionaries, with the outer dictionary keyed by type of plugin\n   * and the inner dictionary keyed by variableName. This is so that even if we have two variables\n   * with the same name in different plugins, we can store their descriptions separately.\n   * @private\n   * @type {{}}\n   */\n  private cache: {};\n  private requests_cache: {}; // temporary requests cache before implementing faster method\n\n  /**\n   * Creates an instance of JsPsychMetadata while passing in JsPsych object to have access to context\n   *  allowing it to access the screen printing information.\n   *\n   * @constructor\n   * @param {JsPsych} JsPsych\n   */\n  constructor() {\n    this.generateDefaultMetadata();\n  }\n  /**\n   * Method that fills in JsPsychMetadata class with all the universal fields with default information.\n   * This is automatically called whenever creating an instance of JsPsychMetadata and indicates all\n   * the required fields that need to filled in to be Psych-DS compliant.\n   */\n  generateDefaultMetadata(): void {\n    this.metadata = {};\n    this.setMetadataField(\"name\", \"title\");\n    this.setMetadataField(\"schemaVersion\", \"Psych-DS 0.4.0\");\n    this.setMetadataField(\"@context\", \"https://schema.org\");\n    this.setMetadataField(\"@type\", \"Dataset\");\n    this.setMetadataField(\"description\", \"Dataset generated using JsPsych\");\n    this.authors = new AuthorsMap();\n    this.variables = new VariablesMap();\n    this.cache = {};\n    this.requests_cache = {};\n  }\n\n  /**\n   * Method that sets simple metadata fields. This method can also be used to update/overwrite existing fields.\n   *\n   * @param {string} key - Metadata field name\n   * @param {*} value - Data associated with the field\n   */\n  setMetadataField(key: string, value: any): void {\n    this.metadata[key] = value;\n  }\n\n  /**\n   * Simple get that accesses the data associated with a field.\n   *\n   * @param {string} key - Field name\n   * @returns {*} - Data associated with the field\n   */\n  getMetadataField(key: string): any {\n    return this.metadata[key];\n  }\n\n  /**\n   * Returns the final Metadata in a single javascript object. Bundles together the author and variables\n   * together in a list rather than object compliant with Psych-DS standards.\n   *\n   * @returns {{}} - Final Metadata object\n   */\n  getMetadata(): {} {\n    const res = this.metadata;\n    res[\"author\"] = this.authors.getList();\n    res[\"variableMeasured\"] = this.variables.getList();\n\n    return res;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {AuthorFields | string} author - All the required or possible fields associated with listing an author according to Psych-DS standards. Option as a string to define an author according only to name.\n   */\n  setAuthor(fields: AuthorFields): void {\n    this.authors.setAuthor(fields); // Assuming `authors` is an instance of the AuthorsMap class\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {(AuthorFields | string | {})} - Object with author information. Empty object if not found.\n   */\n  getAuthor(name: string): AuthorFields | string | {} {\n    return this.authors.getAuthor(name);\n  }\n\n  /**\n   * Method that creates a variable. This method can also be used to overwrite variables with the same name\n   * as a way to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Fields associated with the current Psych-DS standard.\n   */\n  setVariable(variable: VariableFields): void {\n    this.variables.setVariable(variable);\n  }\n\n  /**\n   * Allows you to access a variable's information by using the name of the variable. Can\n   * be used to update fields within a variable, but suggest using updateVariable() to prevent errors.\n   *\n   * @param {string} name - Name of variable to be accessed\n   * @returns {{}} - Returns object of fields\n   */\n  getVariable(name: string): {} {\n    return this.variables.getVariable(name);\n  }\n\n  containsVariable(name: string): boolean {\n    return this.variables.containsVariable(name);\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value.\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Name of field to be updated.\n   * @param {(string | boolean | number | {})} added_value - Value to be used in the update.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    this.variables.updateVariable(var_name, field_name, added_value);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    this.variables.deleteVariable(var_name);\n  }\n\n  /**\n   * Gets a list of all the variable names.\n   *\n   * @returns {string[]} - List of variable string names.\n   */\n  getVariableNames(): string[] {\n    return this.variables.getVariableNames();\n  }\n\n  /**\n   * Method that allows you to display metadata at the end of an experiment.\n   *\n   * @param {string} [elementId=\"jspsych-metadata-display\"] - Id for how to style the metadata. Defaults to default styling.\n   */\n  displayMetadata(display_element) {\n    const elementId = \"jspsych-metadata-display\";\n    const metadata_string = JSON.stringify(this.getMetadata(), null, 2);\n    // const display_element = this.JsPsych.getDisplayElement();\n    display_element.innerHTML += `<p id=\"jspsych-metadata-header\">Metadata</p><pre id=\"${elementId}\" class=\"jspsych-preformat\"></pre>`;\n    document.getElementById(elementId).textContent += metadata_string;\n  }\n\n  /**\n   * Method that begins a download for the dataset_description.json at the end of experiment.\n   * Allows you to download the metadat.\n   */\n  saveAsJsonFile(): void {\n    const jsonString = JSON.stringify(this.getMetadata(), null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"dataset_description.json\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Function to convert string csv into a javascript json object.\n   *\n   * Created by reversing function in datamodule using ChatGPT.\n   *\n   * @private\n   * @param {*} csv - CSV that is represented as string\n   * @returns {*} - Returns a json object\n   */\n  private CSV2JSON(csvString) {\n    const lines = csvString.split(\"\\r\\n\");\n    const result = [];\n    const headers = lines[0].split(\",\").map((header) => header.replace(/\"\"/g, '\"').slice(1, -1));\n\n    for (let i = 1; i < lines.length; i++) {\n      if (!lines[i]) continue; // Skip empty lines\n      const obj = {};\n      const currentLine = lines[i]\n        .split(\",\")\n        .map((value) => value.replace(/\"\"/g, '\"').slice(1, -1));\n\n      headers.forEach((header, index) => {\n        const value = currentLine[index];\n        if (value !== undefined && value !== \"\") {\n          if (!isNaN(value)) {\n            obj[header] = parseFloat(value); // Convert to number if possible\n          } else if (value.toLowerCase() === \"null\") {\n            obj[header] = null; // Set as null if the string is \"null\"\n          } else {\n            try {\n              obj[header] = JSON.parse(value); // Try to parse as JSON (handles objects and arrays)\n            } catch (e) {\n              obj[header] = value; // Use the string value if parsing fails\n            }\n          }\n        }\n        // If value is undefined or empty, skip adding it to the object\n      });\n\n      if (Object.keys(obj).length > 0) {\n        result.push(obj);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Generates observations based on the input data and processes optional metadata.\n   *\n   * This method accepts data, which can be an array of observation objects, a JSON string,\n   * or a CSV string. If the data is in CSV format, set the `csv` parameter to `true` to\n   * parse it into a JSON object. Each observation is processed asynchronously using the\n   * `generateObservation` method. Optionally, metadata can be provided in the form of an\n   * object, and each key-value pair in the metadata object will be processed by the\n   * `processMetadata` method.\n   *\n   * @async\n   * @param {Array|String} data - The data to generate observations from. Can be an array of objects, a JSON string, or a CSV string.\n   * @param {Object} [metadata={}] - Optional metadata to be processed. Each key-value pair in this object will be processed individually.\n   * @param {boolean} [csv=false] - Flag indicating if the data is in a string CSV. If true, the data will be parsed as CSV.\n   */\n  async generate(data, metadata = {}, csv = false) {\n    if (csv) {\n      data = this.CSV2JSON(data);\n    } else if (typeof data === \"string\") {\n      data = JSON.parse(data);\n    }\n\n    if (typeof data !== \"object\") {\n      console.error(\"Unable to parse data object object, not in correct format\");\n      return;\n    }\n\n    for (const observation of data) {\n      await this.generateObservation(observation);\n    }\n\n    for (const key in metadata) {\n      this.processMetadata(metadata, key);\n    }\n  }\n\n  private async generateObservation(observation) {\n    // variables can be thought of mapping of one column in a row\n    const pluginType = observation[\"trial_type\"];\n    const ignored_fields = new Set([\"trial_type\", \"trial_index\", \"time_elapsed\"]);\n\n    for (const variable in observation) {\n      const value = observation[variable];\n\n      if (value === null) continue;\n\n      if (ignored_fields.has(variable)) this.updateFields(variable, value, typeof value);\n      else await this.generateMetadata(variable, value, pluginType);\n    }\n  }\n\n  private async generateMetadata(variable, value, pluginType) {\n    // probably should work in a call to the plugin here\n    const description = await this.getPluginInfo(pluginType, variable);\n    const new_description = description\n      ? { [pluginType]: description }\n      : { [pluginType]: \"unknown\" };\n    const type = typeof value;\n\n    if (!this.containsVariable(variable)) {\n      // probs should have update description called here\n      const new_var = {\n        type: \"PropertyValue\",\n        name: variable,\n        description: { default: \"unknown\" },\n        value: type,\n      };\n      this.setVariable(new_var);\n    }\n\n    // hit the update variable decription fields\n    this.updateVariable(variable, \"description\", new_description);\n    this.updateFields(variable, value, type);\n  }\n\n  private updateFields(variable, value, type) {\n    // calls updates where updateVariable handles logic\n    if (type === \"number\") {\n      this.updateVariable(variable, \"minValue\", value); // technically can refactor one call to do both but makes confusing\n      this.updateVariable(variable, \"maxValue\", value);\n      return;\n    }\n    // calls updates where updateVariable handles logic\n    if (type !== \"number\" && type !== \"object\") {\n      this.updateVariable(variable, \"levels\", value);\n    }\n  }\n\n  private processMetadata(metadata, key) {\n    const value = metadata[key];\n\n    // iterating through variables metadata\n    if (key === \"variables\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Variable object is either null or incorrect type\");\n        return;\n      }\n\n      // all of the variables must already exist because should have datapoints\n      for (let variable_key in value) {\n        if (!this.containsVariable(variable_key)) {\n          console.warn(\"Metadata does not contain variable:\", variable_key);\n          continue;\n        }\n\n        const variable_parameters = value[variable_key];\n\n        if (typeof variable_parameters !== \"object\" || variable_parameters === null) {\n          console.warn(\n            \"Parameters of variable:\",\n            variable_key,\n            \"is either null or incorrect type. The value\",\n            variable_parameters,\n            \"is either null or not an object.\"\n          );\n          continue;\n        }\n\n        // calling updates for each of the renamed parameters within variable/errors handled by method call\n        for (const parameter in variable_parameters) {\n          const parameter_value = variable_parameters[parameter];\n          this.updateVariable(variable_key, parameter, parameter_value);\n          if (parameter === \"name\") variable_key = parameter_value; // renames future instances if changing name\n        }\n      }\n    } // iterating through each individual author class\n    else if (key === \"author\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.warn(\"Author object is not correct type\");\n        return;\n      }\n\n      for (const author_key in value) {\n        const author = value[author_key];\n\n        if (typeof author !== \"string\" && !(\"name\" in author)) author[\"name\"] = author_key; // handles string case and empty name (uses handle)\n\n        this.setAuthor(author);\n      }\n    } else this.setMetadataField(key, value);\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  private async getPluginInfo(pluginType: string, variableName: string) {\n    // Check if the cache for the pluginType exists, if not initialize it\n    if (!this.cache[pluginType]) this.cache[pluginType] = {};\n    else if (variableName in this.cache[pluginType]) {\n      // If the variable already exists in the cache for the plugin, return the cached value\n      return this.cache[pluginType][variableName];\n    }\n\n    // If not, we proceed to fetch script:\n    // Construct the URL for the unpkg service\n    const unpkgUrl = `https://unpkg.com/@jspsych/plugin-${pluginType}/src/index.ts`;\n\n    try {\n      let description = \"unknown\";\n      // check requests cache\n      if (pluginType in this.requests_cache) {\n        const scriptContent = this.requests_cache[pluginType];\n        description = this.getJsdocsDescription(scriptContent, variableName);\n        this.cache[pluginType][variableName] = description;\n      } else {\n        // Fetch the script content from the unpkg URL\n        const response = await fetch(unpkgUrl);\n        const scriptContent = await response.text();\n        this.requests_cache[pluginType] = scriptContent;\n        console.log(scriptContent);\n\n        // Extract the JSDoc description for the variable from the script content\n        description = this.getJsdocsDescription(scriptContent, variableName);\n\n        // Check again if the cache for the pluginType exists, if not initialize it\n        if (!this.cache[pluginType]) this.cache[pluginType] = {}; // don't think this ever returns true, might be able delete\n\n        // Cache the description for the variable in the pluginType cache\n        this.cache[pluginType][variableName] = description;\n        // Return the description\n      }\n\n      return description;\n    } catch (error) {\n      console.error(`Failed to fetch info from ${unpkgUrl}:`, error); // DISABLING to test other features\n      // Error is likely due to 1)a fetch failure, or 2)no JSDoc comments in the script content matched.\n      //HANDLE FETCH FAILURE CASES\n      // In case of the latter, we cache the null value to prevent repeated fetch attempts.\n\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      this.cache[pluginType][variableName] = null;\n\n      return \"failed with error\";\n    }\n  }\n\n  /**\n   * Extracts the description for a variable of a plugin from the JSDoc comments present in the script of the plugin. The script content is\n   * drawn from the remotely hosted source file of the plugin through getPluginInfo. The script content is taken\n   * as a string and Regex is used to extract the description.\n   *\n   *\n   * @param {string} scriptContent - The content of the script from which the JSDoc description is to be extracted.\n   * @param {string} variableName - The name of the variable for which the JSDoc description is to be extracted.\n   * @returns {string} The extracted JSDoc description, cleaned and trimmed.\n   */\n  private getJsdocsDescription(scriptContent: string, variableName: string) {\n    // Regex to match part of the content that starts with 'parameters:' and ends with '};', which\n    // is parameters info. THIS MUST BE CHANGED TO data FOR NEW PLUGIN LAYOUT\n    const paramRegex = scriptContent.match(/parameters:\\s*{([\\s\\S]*?)};\\s*/).join();\n\n    // Regex that matches everything up to the variable name\n    const regex = new RegExp(`((.|\\n)*)(?=${variableName}:)`);\n\n    // Regex on paramRegex, to get everything from 'paramaters:' to the variable name.\n    const variableRegex = paramRegex.match(regex)[0];\n\n    // Finds the index of the last occurence of `/**` in the variableRegex string, and slices it from there\n    // to give the JSDoc comment for our variable.\n    const descrip = variableRegex.slice(variableRegex.lastIndexOf(\"/**\"));\n\n    // Regex to remove the leading and trailing '/**' and '*/' characters.\n    const clean = descrip.match(/(?<=\\*\\*)([\\s\\S]*?)(?=\\*\\/)/)[1];\n\n    //CLEANING:\n    // Regex to remove all newline characters.\n    const cleaner = clean.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n    // Remove all '*' characters from the JSDoc comment.\n    const cleanest = cleaner.replace(/\\*/gm, \"\");\n\n    // Return the cleaned JSDoc comment, trimmed of leading and trailing whitespace\n    return cleanest.trim();\n  }\n}\n"],"names":["key"],"mappings":"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"}